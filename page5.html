<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

<link href="images/style.css" rel="stylesheet" type="text/css" />
</head>

<body>
<table width="100%" border="0" cellspacing="0" cellpadding="15">
  <tr>
    <td align="right"><font size="+3"><strong><a name="up" id="up"></a>Asymmetric Key Cryptography</strong></font></td>
  </tr>
  <tr>
    <td><hr />
      <table width="100%" border="0" cellspacing="0" cellpadding="0">
        <tr>
          <td colspan="2"><strong>เนื้อหา 4.</strong><strong> Asymmetric Key Cryptography</strong></td>
        </tr>
        <tr>
          <td width="4%" bgcolor="#CCCCCC">&nbsp;</td>
          <td width="96%" bgcolor="#CCCCCC">4.1 <a href="#a">RSA</a><br />
4.2 <a href="#b">ECC</a></td>
        </tr>
      </table>
      <p><strong>4.</strong><strong> Asymmetric Key Cryptography</strong><br />
         การเข้ารหัสแบบอสมมาตร (Asymmetric Key Cryptography) บางตำราอาจใช้คำว่า Asymmetric Key Encryption หรือ Public Key Encryption หรือใช้คำว่า Public Key Infrastructure (PKI) หรือ Public-Key Cryptography<br />
         การเข้ารหัสแบบนี้ถูกคิดค้นโดย Whit Diffie และ Marty Hellman ตั้งแต่ปี1976 โดยถูกสร้างมาเพื่อเป็นทางเลือกในการส่งข้อมูลที่เป็นความลับ เพราะการเข้ารหัสแบบสมมาตร (ใช้กุญแจดอกเดียว) จะมีปัญหาเรื่องการถูกดักจับ Key และปัญหาเกี่ยวกับการจัดการ Key ที่มีอยู่เป็นจำนวนมากเมื่อใช้ในระบบใหญ่ การเข้ารหัสแบบอสมมาตรจะใช้ Key สองอัน โดยหากเราเข้ารหัสด้วย Key อันหนึ่งจะต้องทำการถอดรหัสด้วย Key อีกอันหนึ่งที่เหลือ<br />
</p>
    <p><strong>ตัวอย่างเช่น</strong><strong> </strong><br />
      - หากเข้ารหัสด้วย Key1 จะต้องถอดรหัสด้วย Key2 เท่านั้น<br />
      - หากเข้ารหัสด้วย Key2 จะต้องถอดรหัสด้วย Key1 เท่านั้น<br />
      - หากเข้ารหัสด้วย Key1 แล้วถอดรหัสด้วย Key1 จะไม่สามารถถอดรหัสได้<br />
      - หากเข้ารหัสด้วย Key2 แล้วถอดรหัสด้วย Key2 จะไม่สามารถถอดรหัสได้</p>
    <p>         การประยุกต์ใช้งานทำได้โดย เก็บ Key อันหนึ่งไว้กับตัวเองเรียกว่า Private Key ส่อนอีก Key หนึ่งสามารถที่จะแจกจ่ายให้ผู้อื่นได้ดังนั้น Key นี้จึงถูกเรียกว่า Public Key เมื่อผู้อื่นต้องการที่จะส่งข้อมูลที่เป็นความลับมายังเจ้าของ Private Key จะต้องทำการเข้ารหัสข้อมูลนั้นด้วย Public Key ของผู้รับ ดังนั้นจึงทำให้ผู้ที่มี Private Key เท่านั้นที่จะถอดรหัสข้อมูลได้ ส่วนการส่งข้อมูลที่เข้ารหัสด้วย Private Key ไปยังผู้อื่น ผู้ใดก็ตามที่มี Public Key (ซึ่งมีอยู่หลายคน) จะสามารถถอดรหัสข้อมูลได้</p>
    <p><strong><em>ตัวอย่างที่ 1</em></strong></p>
    <p>1. สร้าง Private Key และ Public Key ของผู้ใช้ A ขึ้นมา เรียกว่า PvK-A และ PbK-A 1 ตามลำดับ</p>
    <p>2. ผู้ใช้ A แจกจ่าย Public Key ของตน (PbK-A) ไปให้กับผู้ใช้ และผู้ใช้ C</p>
    <p>3. ผู้ใช้ B สามารถส่งข้อมูลลับ มายังผู้ใช้ A ได้ โดยเข้ารหัสข้อมูลด้วย Pbk-A ซึ่งทำให้</p>
    <p>· ผู้ใช้ A ถอดรหัสได้เพราะมี PvK-A (เนื่องจากข้อมูลเข้ารหัสด้วย PbK-A จึงต้องถอดด้วย PvK-A ซึ่งผู้ใช้ A มีคีย์นี้)</p>
    <p>· ผู้ใช้ C ถึงแม้ดักจับ Cipher Text ของผู้ใช้ B ได้ แต่ก็ไม่สามารถถอดรหัสได้ เพราะไม่มี PvK-A (เนื่องจาก Private Key จะถูกเก็บไว้ที่เจ้าของเท่านั้น)</p>
    <p>4 ผู้ใช้ C สามารถส่งข้อมูลลับมายังผู้ใช้ A ได้ โดยเข้ารหัสข้อมูลด้วย PbK-A ซึ่งทำให้ผู้ใช้ A ถอดรหัสได้ แต่ผู้ใช้อื่นถอดรหัสไม่ได้</p>
    <p>5 ผู้ใช้ A ต้องการส่งข้อมูลที่ “ไม่เป็นความลับ” ไปให้ผู้ใช้ B โดยเข้ารหัสข้อมูลด้วย PvK-A ซึ่งทำให้</p>
    <p>· ผู้ใช้ B สามารถถอดรหัสข้อมูลได้โดยใช้ PbK-A และมั่นใจได้ว่าเป็นข้อมูลนี้มาจาก A เนื่องจากข้อมูลที่ถอดด้วย PbK-A ได้จะต้องถูกเข้ารหัสด้วย PvK-A ซึ่งผู้ที่มีคีย์นี้มีอยู่คนเดียวเท่านั้นคือผู้ใช้ A</p>
    <p>· ผู้ใช้ C ดักจับ Cipher Text ได้ ก็จะสามารถถอดรหัสข้อมูลได้โดยใช้ PbK-A แต่เนื่องจากข้อมูลนี้เป็นข้อมูลที่ “ไม่เป็นความลับ” จึงไม่ได้เกิดปัญหาอะไร</p>
    <p>NOTE : การเข้ารหัสโดยใช้ Private Key ของผู้ส่ง สามารถยืนยันตัวผู้ส่งได้</p>
    <p><strong><em>ตัวอย่างที่ 2</em></strong></p>
    <p>1. สร้าง Private Key และ Public Key ของผู้ใช้ A ขึ้นมา เรียกว่า PvK-A และ PbK-</p>
    <p>A ตามลำดับ</p>
    <p>2. สร้าง Private Key และ Public Key ของผู้ใช้ B ขึ้นมา เรียกว่า PvK-B และ PbK-B ตามลำดับ</p>
    <p>3. หาก A ต้องการจะส่งข้อมูลที่เป็นความลับไปยัง B จะต้องเข้ารหัสข้อมูลด้วย PbK-B ซึ่ง B จะเป็นคนเดียวที่สามารถถอดรหัส</p>
    <p>ได้ เพราะมี PvK-B</p>
    <p>4. หาก B ต้องการจะส่งข้อมูลที่เป็นความลับไปยัง A จะต้องเข้ารหัสข้อมูลด้วย PbK-A ซึ่ง A จะเป็นคนเดียวที่สามารถถอดรหัส</p>
    <p>ได้ เพราะมี PvK-A</p>
    <p>5. A เข้ารหัสข้อมูลด้วย PvK-A ส่งไปยัง B เมื่อ B ได้รับและถอดรหัสด้วย PbK-A ออกมาได้จึงมั่นใจได้ว่าข้อมูลถูกส่งมาจาก A</p>
    <p>(เพราะหากถอดรหัสด้วย PbK-A แสดงว่าข้อมูลนี้จะต้องถูกเข้ารหัสด้วย PvK-A)</p>
    <p>6. B เข้ารหัสข้อมูลด้วย PvK-B ส่งไปยัง A เมื่อ A ได้รับและถอดรหัสด้วย PbK-B ออกมาได้จึงมั่นใจได้ว่าข้อมูลถูกส่งมาจาก B</p>
    <p>(เพราะหากถอดรหัสด้วย PbK-B แสดงว่าข้อมูลนี้จะต้องถูกเข้ารหัสด้วย PvK-B)</p>
    <p>อัลกอริทึมที่ใช้ในการเข้ารหัสแบบอสมมาตร (Asymmetric Key Cryptography) ที่เป็นที่นิยม ได้แก่ RSA และ ECC</p>
    <hr />
    <p align="right"><a href="#up"><img src="images/btn_top.gif" width="48" height="43" border="0" /></a></p>
    <p><strong><a name="a" id="a"></a>4.1</strong><strong> RSA</strong><br />
         RSA เป็นอัลกอริทึมในการเข้าหัสแบบอสมมาตร ถูกสร้างขึ้นมาเมื่อปี1978 โดย Ron Rivest, Adi Shamir และ Leonard Adleman ตั้งแต่คิดค้นมายังไม่มีใครสามารถเบรคอัลกอริทึมนี้ได้ และ RSA ได้ถูกนำมาใช้อย่างแพร่หลายในด้าน e-commerce <br />
<strong>4.1.1 กระบวนการทำงานของ </strong><strong>RSA </strong><br />
(1) เลือก p และ q ซึ่งเป็นจำนวนเฉพาะที่มีค่าต่างกัน<br />
(2) ให้ n = pq<br />
(3) ให้ m = (p-1)(q-1)<br />
(4) เลือกค่า e ที่ 1 &lt; e &lt; m ซึ่งหารร่วมมากของ m กับ e มีค่าเป็น 1 (สามารถหาค่า e ได้โดยการสุ่มค่าจำนวนเต็มบวกพร้อมกับทดสอบว่าหารร่วมมากของ m กับ e มีค่าเป็น 1)<br />
(5) หาค่า d ที่ทำให้  ed mod m = 1<br />
(6) Public key  คือ (e,n)<br />
(7) Private key คือ (d,n)<br />
(8) ให้ M คือข้อความที่ยังไม่ถูกเข้ารัหส (ในรูปแบบของตัวเลข) M &lt; n<br />
(9) การเข้ารหัส =&gt;      C = M^e mod n<br />
(10) การถอดรหัส =&gt;  M = C^d mod n</p>
    <p>สาเหตุที่ทำให้ RSA ยากที่จะทำการเบรคได้คือ แม้จะทราบ Public Key (e,n) ทราบค่า Message (M) และทราบค่า Cipher (C) ก็ตาม แต่ก็ยากที่จะทำการคำนวณย้อนกลับเพื่อหาค่าของ Private Key (d) ได้</p>
    <p><strong>4.1.2 ตัวอย่างการเข้ารหัสและถอดรหัสด้วย </strong><strong>RSA</strong><br />
      (1) เลือก p และ q ซึ่งเป็นจำนวนเฉพาะที่มีค่าต่างกัน<br />
                        p = 7<br />
                        q = 17<br />
      (2) ให้ n = pq<br />
                        ดังนั้น n = 7*17 = 119<br />
       <br />
      (3) ให้ m = (p-1)(q-1)<br />
                        ดังนั้น m = 6*16 = 96 </p>
    <p>(4) เลือกค่า e ที่ 1 &lt; e &lt; m ซึ่งหารร่วมมากของ m กับ e มีค่าเป็น 1 (สามารถหาค่า e ได้โดยการส่มค่าจำนวนเต็มบวกพร้อมกับทดสอบว่าหารร่วมมากของ m กับ e มีค่าเป็น 1) เลือก e = 5 และทดสอบหารร่วมมากของ 96 กับ 5 แล้วได้ 1<br />
       <br />
      (5) หาค่า d ที่ทำให้  ed mod m = 1<br />
                        ได้ค่า d = 77 เพราะ 5*77 mod 96 ได้ 1 <br />
       <br />
      (6) Public key  คือ (e,n)<br />
                        ดังนั้น Public key  คือ (5,119)</p>
    <p>(7) Private key คือ (d,n)<br />
                        ดังนั้น Private key คือ (77,119)<br />
       <br />
      (8) ให้ M คือข้อความที่ยังไม่เข้ารหัส (ในรูปแบบของตัวเลข) M &lt; n<br />
                        ให้ข้อความที่ยังไม่เข้ารหัส M = 19<br />
       <br />
      (9) การเข้ารหัส =&gt;      C = M^e mod n<br />
                        ได้ C = 19^5 mod 119 = 66<br />
       <br />
      (10) การถอดรหัส =&gt;  M = C^d mod n<br />
                        ได้ M = 66^77 mod 119 = 19  </p>
    <hr />
    <p align="right"><a href="#up"><img src="images/btn_top.gif" width="48" height="43" border="0" /></a></p>
    <p><strong><a name="b" id="a2"></a>4.2</strong><strong> ECC</strong><br />
               ECC ย่อมาจาก Elliptic Curves Cryptography ได้รับการนำเสนอโดย Neal Koblitz และ Victor S. Miller ในปี 1985</p>
    <p>โดยอัลกอริทึมการเข้ารัหส ECC นี้ได้รับการพัฒนาจากสมการของเส้นโค้งของวงรี <br />
      <strong>                    y^2= x^3 + ax + b </strong><br />
    </p>
    <p align="center"> <img width="307" height="321" src="images/clip_image002_0002.png" /> <br />
      กราฟแสดงความสัมพันธ์ของสมการ Elliptic Curves</p>
    <p><br />
               ECC มีข้อดีที่เหนือกว่า RSA คือจะใช้คีย์ที่สั้นกว่าแต่สามารถให้ความปลอดภัยเท่ากับ RSA ได้ หรือหากใช้คีย์ที่ยาวเท่ากับคีย์ของ RSA จะมีความปลอดภัยสูงกว่า คือหากต้องการที่จะเบรคจะใช้เวลาในการ Brute Force นานกว่า RSA<br />
               เนื่องจาก ECC ใช้ Key ที่มีขนาดเล็กกว่า RSA มาก และมีความสามารถในการคำนวณที่รวดเร็ว ใช้พลังงานต่ำและใช้หน่วยความจำน้อย ดังนั้น ECC จึงเหมาะสำหรับการใช้งานในอุปกรณ์เคลื่อนที่ขนาดเล็กอย่างเช่น โทรศัพท์มือถือ Pocket PC และ PDA เป็นต้น</p>
    <p align="center"><img width="431" height="417" src="images/clip_image004_0001.png" /> <br />
    กราฟเปรียบตารางที่ใช้ในการแคร็ก ECC เทียบกับ RSA</p>
    <hr />
    <p align="right"><a href="#up"><img src="images/btn_top.gif" width="48" height="43" border="0" /></a></p></td>
  </tr>
</table>
</body>
</html>
