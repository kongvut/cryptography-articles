<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

<link href="images/style.css" rel="stylesheet" type="text/css" />
</head>

<body>
<table width="100%" border="0" cellspacing="0" cellpadding="15">
  <tr>
    <td align="right"><font size="+3"><strong><a name="up" id="up"></a>โพรโทคอลในการพิสูจน์ตัวตน </strong></font></td>
  </tr>
  <tr>
    <td><hr />
      <table width="100%" border="0" cellspacing="0" cellpadding="0">
        <tr>
          <td colspan="2"><strong>เนื้อหา 9. โพรโทคอลในการพิสูจน์ตัวตน</strong><strong> </strong></td>
        </tr>
        <tr>
          <td width="4%" bgcolor="#CCCCCC">&nbsp;</td>
          <td width="96%" bgcolor="#CCCCCC">9.1 <a href="#a">Secure Socket Layer (SSL)</a><br />
9.2 <a href="#b">Secure Shell (SSH)</a><br />
9.3 <a href="#c">Internet Protocol Security (IPsec)</a><br />
9.4 <a href="#d">Kerberos</a></td>
        </tr>
      </table>
      <p><strong>9. โพรโทคอลในการพิสูจน์ตัวตน</strong><strong> </strong><br />
         ในระบบเครือข่ายแบบเปิดหรืออินเทอร์เน็ต การพิสูจน์ตัวตนถือได้ว่าเป็นกระบวนการเริ่มต้นและมีความสำคัญที่สุดในการปกป้องเครือข่ายให้ปลอดภัย โพรโทคอลในการพิสูจน์ตัวตน คือโพรโทคอลการสื่อสารที่มีกระบวนการพิสูจน์ตัวตนรวมอยู่ในชุดโพรโทคอล   ตัวอย่างของโพรโทคอลในการพิสูจน์ตัวตนได้แก่ <br />
- Secure Socket Layer (SSL) <br />
- Secure Shell (SSH) <br />
- Internet Security (IPSEC) <br />
- Kerberos</p>
    <p><strong><a name="a" id="a"></a>9.1 Secure Socket Layer (SSL)</strong><br />
               Secure Sockets Layer (SSL) เริ่มพัฒนาโดย Netscape Communications เพื่อใช้ในโพรโทคอลระดับแอพพลิเคชันคือ Hypertext Transfer Protocol (HTTP) ซึ่งเป็นการสื่อสารผ่านเว็บให้ปลอดภัย พัฒนาในช่วงต้นของยุคการค้าอิเล็กทรอนิคส์กำลังได้รับความนิยมในโลกอินเทอร์เน็ต SSL ทำให้เกิดการสื่อสารอย่างปลอดภัยระหว่างไคลเอ็นต์และเซิร์ฟเวอร์ โดยการอนุญาตให้มีกระบวนการพิสูจน์ตัวตนร่วมกับการใช้งานลายเซ็นดิจิตอลสำหรับการรักษาความถูกต้องของข้อมูลและการเข้ารหัสข้อมูลเพื่อป้องกันความเป็นส่วนตัวระหว่างการสื่อสารข้อมูล<br />
               โพรโทคอล SSL อนุญาตให้สามารถเลือกวิธีการในการเข้ารหัส วิธีสร้างไดเจสต์และลายเซ็นดิจิตอล ได้อย่างอิสระก่อนการสื่อสารจะเริ่มต้นขึ้น ตามความต้องการของทั้งเว็บเซิร์ฟเวอร์และบราวเซอร์ ทั้งนี้เพื่อเพิ่มความยืดหยุ่นในการใช้งาน เปิดโอกาสให้ทดลองใช้วิธีการในการเข้ารหัสวิธีใหม่ รวมถึงลดปัญหาการส่งออกวิธีการเข้ารหัสไปประเทศที่ไม่อนุญาต</p>
    <p><strong>กระบวนการในการเริ่มต้นการสื่อสารผ่านชั้น </strong><strong>SSL แบ่งเป็น 4 ขั้นตอนคือ</strong><br />
      - ประกาศชุดวิธีการเข้ารหัส ไดเจสต์ และลายเซ็นดิจิตอลที่สนับสนุนของทั้งไคลเอ็นต์และเซิร์ฟเวอร์ <br />
      - การพิสูจน์ตัวตนของเซิร์ฟเวอร์ต่อไคลเอ็นต์ <br />
      - การพิสูจน์ตัวตนของไคลเอ็นต์ต่อเซิร์ฟเวอร์ ถ้าจำเป็น <br />
      - ไคลเอ็นต์และเซิร์ฟเวอร์ตกลงชุดวิธีการเข้ารหัส การสร้างไดเจสต์ และการใช้ลายเซ็นดิจิตอล </p>
    <hr />
    <p align="right"><a href="#up"><img src="images/btn_top.gif" width="48" height="43" border="0" /></a></p>
    <p><strong><a name="b" id="a2"></a>9.2</strong><strong> Secure Shell (SSH)</strong><br />
               การใช้งาน SSH เป็นการติดต่อสื่อสารโดยใช้การพิสูจน์ตัวตนร่วมกับลายเซ็นดิจิตอล และมีการเข้ารหัสการสื่อสาร ตรงกันข้ามกับการสื่อสารแบบเก่าเช่น Telnet หรือ R Utilities</p>
    <p><strong>การติดต่อสื่อสารตามโพรโทคอล </strong><strong>SSH เป็นไปตามขั้นตอนสรุปได้ดังนี้</strong><br />
      - ไคลเอ็นต์เริ่มถามเวอร์ชันของโพรโทคอล SSH บนเซิร์ฟเวอร์ ถ้าใช้ SSH เวอร์ชันเดียวกันถือว่าสื่อสารกันได้ <br />
      - ไคลเอ็นต์จะประกาศวิธีการเข้ารหัส วิธีการสร้างไดเจสต์ และการแลกเปลี่ยนกุญแจในการเข้ารหัสที่สนับสนุน <br />
      - เซิร์ฟเวอร์จะทำหน้าที่เลือกชุดวิธีการทั้งหมดที่ไคลเอ็นต์สนับสนุน <br />
      - ไคลเอ็นต์และเซิร์ฟเวอร์เริ่มต้นแลกเปลี่ยนกุญแจในการเข้ารหัส ตามรูปแบบวิธีการแลกเปลี่ยนกุญแจด้วยวิธีการกุญแจสาธารณะเช่นการใช้วิธี Diffie-Hellman เป็นต้น <br />
      - เมื่อแลกเปลี่ยนกุญแจสำหรับการเข้ารหัสด้วยวิธีการแลกเปลี่ยนกุญแจแล้ว ทั้งไคลเอ็นต์และเซิร์ฟเวอร์จะสามารถเริ่มต้นติดต่อสื่อสารด้วยการเข้ารหัสด้วยกุญแจที่ได้จากการแลกเปลี่ยนกุญแจและสามารถใช้การบีบอัดข้อมูลร่วมได้ </p>
    <p>         โพรโทคอล SSH ยังสนับสนุนการพิสูจน์ตัวตนของทั้งเซิร์ฟเวอร์และไคลเอ็นต์ในขั้นตอนการแลกเปลี่ยนกุญแจด้วย กล่าวคือในขั้นตอนการแลกเปลี่ยนกุญแจนั้น ทั้งไคลเอ็นต์และเซิร์ฟเวอร์จะสร้างคู่รหัสกุญแจ ประกอบไปด้วยกุญแจสาธารณะและกุญแจส่วนตัว ซึ่งกุญแจส่วนตัวของทั้งไคลเอ็นต์และเซิร์ฟเวอร์นี้เองที่ใช้ในการพิสูจน์ตัวตนได้ตามหลักการพิสูจน์ตัวตนด้วยวิธีการใช้กุญแจสาธารณะ ถ้าตรวจสอบได้ว่ามีการส่งข้อมูลด้วยกุญแจที่เปลี่ยนไปจากเดิม อาจจะแสดงได้ว่าการสื่อสารนี้ไม่ปลอดภัยแล้ว</p>
    <hr />
    <p align="right"><a href="#up"><img src="images/btn_top.gif" width="48" height="43" border="0" /></a></p>
    <p><strong><a name="c" id="a3"></a>9.3</strong><strong> Internet Protocol Security (IPsec)</strong><br />
               IPsec เป็นส่วนเพิ่มขยายของ Internet Protocol (IP) ในชุดโพรโทคอล TCP/IP พัฒนาเพื่อเป็นส่วนหนึ่งของมาตรฐานของ IPv6 ซึ่งเป็นโพรโทคอลที่พัฒนาเพื่อใช้แทน IPv4 ที่ใช้ในปัจจุบันและกำหนดหมายเลข RFC เป็น RFC24011<br />
               IPsec ใช้โพรโทคอล 2 ชุดคือ Authentication Header (AH) และ Encapsulated Security Payload (ESP) เพื่อรองรับการพิสูจน์ตัวตน (Authentication) การรักษาความถูกต้องของข้อมูล (Integrity) และการรักษาความลับ (Confidentiality) ในระดับชั้นของ IP การทำงานของ IPsec แบ่งเป็น 2 โหมดการทำงานได้แก่<br />
      - Tunnel mode เป็นการนำส่วนแพ็กเก็ตเดิมทั้งหมดมาครอบด้วย IP โพรโทคอลชุดใหม่ที่เป็นไปตามชุดโพรโทคอล IPsec สังเกตได้จากมีการเพิ่มเฮดเดอร์ IP และ AH เข้าไปข้างหน้าแพ็กเก็ตชุดเดิม <br />
      - Transport mode นำเฉพาะข้อมูลของโพรโทคอล IP ซึ่งจะประกอบด้วยข้อมูลของชั้น Transport (TCP หรือ UDP) และชั้นแอพพลิเคชัน โดยเพิ่มโพรโทคอล AH และเพิ่มข้อมูลใน IP เดิมให้เหมาะสมตามมาตรฐาน IPsec </p>
    <p>         การรักษาความถูกต้องของข้อมูลของ IP ดาตาแกรม (IP Datagram) ในชุดโพรโทคอล IPsec ใช้ Hash Message Authentication Codes หรือ HMAC ด้วยฟังก์ชันแฮชเช่น MD5 หรือ SHA-1 ทุกครั้งที่มีการส่งแพ็กเก็ตจะมีการสร้าง HMAC และใช้การเข้ารหัสไปด้วยทุกครั้ง เพื่อให้ปลายทางสามารถตรวจสอบได้ตามหลักการลายเซ็นดิจิตอลว่าต้นทางเป็นผู้ส่งแพ็กเก็ตนั้นมาจริง ส่วนการรักษาความลับของข้อมูลนั้น จะใช้การเข้ารหัส IP ดาตาแกรมด้วยวิธีการเข้ารหัสด้วยกุญแจสมมาตร ด้วยวิธีการมาตรฐานที่เป็นรู้จักกันดีเช่น 3DES AES หรือ Blowfish เป็นต้น</p>
    <hr />
    <p align="right"><a href="#up"><img src="images/btn_top.gif" width="48" height="43" border="0" /></a></p>
    <p><strong><a name="d" id="a4"></a>9.4</strong><strong> Kerberos</strong><br />
               การพิสูจน์ตัวตนแบบ Kerberos พัฒนาขึ้นโดย Massachusetts Institute of Technology (MIT) <br />
      ระบบ Kerberos ประกอบขึ้นจากสองส่วนหลักได้แก่<br />
      - Ticket ใช้สำหรับการพิสูจน์ตัวตนของผู้ใช้ในระบบ และการเข้ารหัสข้อมูล <br />
      - Authenticator ใช้ในการตรวจสอบ Ticket ว่าเป็นผู้ใช้คนเดียวกันที่ใช้ Ticket เป็นใบเบิกทางเข้าสู่ระบบและเป็นผู้ใช้ที่ระบบสร้างให้อย่างถูกต้อง </p>
    <p><strong>Kerberos เซิร์ฟเวอร์ มีสองส่วนบริการในการใช้งานคือ</strong><br />
      - Authentication service (AS) สำหรับการพิสูจน์ตัวตนของผู้ใช้กับ Kerberos เซิร์ฟเวอร์ก่อนการเข้าใช้บริการ <br />
      - Ticket Granting Service (TGS) เป็นบริการที่ออก Ticket เพื่อให้ผู้ใช้นำไปใช้กับเซิร์ฟเวอร์ที่ต้องการ </p>
    <p><strong>กระบวนการใช้งานระบบ </strong><strong>Kerberos มีลำดับดังนี้ </strong><br />
      - ผู้ใช้จะทำการพิสูจน์ตัวตนครั้งแรกกับ Authentication service ของ Kerberos ซึ่งจะได้กุญแจสมมาตรซึ่งจะใช้ในการเข้ารหัสข้อมูลในการติดต่อสื่อสาร <br />
      - ก่อนผู้ใช้จะเข้าไปใช้บริการใด ๆ ในระบบได้ต้องมี Ticket ก่อน ด้วยการติดต่อไปที่ Ticket Granting Service เพื่อให้ออก Ticket ที่เหมาะสมกับการเข้าไปใช้บริการบนเซิร์ฟเวอร์ในระบบได้  <br />
      -ผู้ใช้นำ Ticket สำหรับไปใช้กับการร้องขอการติดต่อการบริการจากเซิร์ฟเวอร์ในระบบ </p>
         ปัญหาสำคัญของการใช้ระบบ Kerberos คือการขยายระบบเนื่องจากเซิร์ฟเวอร์ Kerberos ต้องเก็บกุญแจของผู้ใช้ทุกคนที่เข้ามาในระบบ ถ้าระบบใหญ่มากขึ้น มีการกระจายตัวมากกว่าหนึ่งจุด ย่อมส่งผลเสียต่อการใช้งานระบบโดยรวม แต่การนำระบบ Kerberos มาใช้จะเพิ่มความสะดวกในการพิสูจน์ตัวตนได้มากขึ้น มักเรียกการใช้งาน Kerberos ว่าเป็นระบบ Single Sign-On แบบหนึ่ง คือการเข้าถึงการใช้บริการของระบบทั้งหมดได้ด้วยการพิสูจน์ตัวตนเพียงครั้งเดียว
<hr />
<p align="right"><a href="#up"><img src="images/btn_top.gif" width="48" height="43" border="0" /></a></p></td>
  </tr>
</table>
</body>
</html>
